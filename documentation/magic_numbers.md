# Magic Numbers Analysis Report

**Project:** Guitar Tuner Android Application  
**Date:** January 29, 2026  
**Generated by:** opencode analysis

## Summary

This report identifies and documents all numeric literals ("magic numbers") in the codebase. Magic numbers are hard-coded numeric values that lack clear semantic meaning and should typically be replaced with named constants for improved code maintainability, readability, and ease of modification.

### Overall Statistics

| Language | Files Analyzed | Magic Numbers Found | Already Named | Should Be Extracted |
|----------|---------------|---------------------|---------------|---------------------|
| Kotlin   | 8             | 155                 | 18            | 137                 |
| Python   | 3             | 32                  | 0             | 32                  |
| **Total** | **11**       | **187**             | **18**        | **169**             |

### Key Categories of Magic Numbers

1. **Audio Processing Constants**: Sample rates, buffer sizes, frequency thresholds
2. **Musical Constants**: Reference frequencies, note calculations, cent conversions
3. **UI/UX Constants**: Timing delays, sensitivity ranges, slider boundaries
4. **Icon Generation Constants**: Dimensions, scaling factors, geometric ratios

---

## Kotlin Files Analysis

### 1. `AudioRecorder.kt` - Audio recording configuration

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 16 | `0` | Initial read counter value | No | `readCounter = 0` | Extract as `INITIAL_READ_COUNTER` |
| 20 | `44100` | Audio sample rate | Yes | `SAMPLE_RATE = 44100` | Already properly defined |
| 23 | `4096` | Default buffer size in bytes | Yes | `BUFFER_SIZE_BYTES = 4096` | Already properly defined |
| 42 | `16` | Bits per sample | No | Comment: "16-bit samples" | Extract as `BITS_PER_SAMPLE` |
| 43 | `2` | Bytes per short | No | Division for buffer size conversion | Extract as `BYTES_PER_SHORT` |
| 54 | `2` | Buffer size multiplier | No | `minBufferSizeBytes * 2` | Extract as `BUFFER_SIZE_MULTIPLIER` |
| 61 | `2` | Buffer size multiplier | No | `minBufferSizeBytes * 2` | Extract as `BUFFER_SIZE_MULTIPLIER` |
| 65 | `1` | AudioRecord initialized state | No | Comment: "(1=initialized)" | Extract as `AUDIO_RECORD_INITIALIZED` |
| 74 | `3` | AudioRecord recording state | No | Comment: "(3=recording)" | Extract as `AUDIO_RECORD_RECORDING` |
| 76 | `2` | Buffer size multiplier | No | `${minBufferSizeBytes * 2}` | Already defined above |
| 101 | `0` | Buffer read start offset | No | `audioRecord.read(buffer, 0, ...)` | Extract as `BUFFER_READ_OFFSET` |
| 103 | `0` | Comparison for empty read | No | `bytesRead <= 0` | Use `NO_DATA_READ` constant |
| 109 | `10` | Logging threshold for initial reads | No | `readCounter <= 10` | Extract as `INITIAL_LOG_THRESHOLD` |
| 109 | `20` | Logging frequency modulus | No | `readCounter % 20 == 0` | Extract as `LOG_FREQUENCY_MODULUS` |
| 112 | `0.0` | Initial sum for RMS calculation | No | `var sum = 0.0` | Use `INITIAL_SUM` constant |
| 113 | `0` | Initial max amplitude | No | `var maxAbs = 0` | Use `INITIAL_MAX_AMPLITUDE` |
| 114 | `0.0` | Initial sum of squares | No | `var sumSquares = 0.0` | Use `INITIAL_SUM_SQUARES` |
| 115 | `0` | Loop start index | No | `for (i in 0 until bytesRead)` | Standard loop idiom (acceptable) |
| 129 | `5` | Number of samples to log | No | Comment: "Log first 5 samples" | Extract as `SAMPLES_TO_LOG` |
| 130 | `5` | Minimum samples for logging | No | `bytesRead >= 5` | Same as above |
| 131 | `0`, `1`, `2`, `3`, `4` | Sample indices to log | No | `buffer[0]`, `buffer[1]`, etc. | Use loop instead of hardcoded indices |
| 136 | `0` | Loop start for conversion | No | `for (i in 0 until bytesRead)` | Standard loop idiom (acceptable) |

**File Summary:** Contains 22 magic numbers, with 2 already defined as named constants (`SAMPLE_RATE`, `BUFFER_SIZE_BYTES`). Most represent audio processing parameters that should be extracted.

### 2. `AudioConfig.kt` - Audio configuration constants

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 4 | `44100` | Audio sample rate | Yes | `SAMPLE_RATE = 44100` | Already properly defined |
| 5 | `4096` | Buffer size in bytes | Yes | `BUFFER_SIZE = 4096` | Already properly defined |
| 6 | `440.0` | Reference frequency (A4) | Yes | `DEFAULT_REFERENCE_FREQUENCY = 440.0` | Already properly defined |
| 7 | `50.0` | Maximum cents deviation | Yes | `MAX_CENTS_DEVIATION = 50.0` | Already properly defined |
| 7 | `50` | Integer version of above | No | Same line as `50.0` | Already covered by constant |

**File Summary:** This file is well-structured with named constants. Only one redundant integer literal found.

### 3. `PitchDetector.kt` - Pitch detection algorithm

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 12 | `0.00055` | Default minimum RMS threshold | Yes | `DEFAULT_MIN_RMS_THRESHOLD = 0.00055` | Already properly defined |
| 12 | `0.055` | Percentage comment value | No | Comment: "0.055% of max amplitude" | Could extract as `PERCENTAGE_THRESHOLD` |
| 13 | `0.8` | Default clarity threshold | Yes | `DEFAULT_CLARITY_THRESHOLD = 0.8` | Already properly defined |
| 14 | `0` | Float literal suffix | No | `0.05f` formatting | Language syntax (acceptable) |
| 18 | `0`, `100` | Sensitivity range bounds | No | Comment: "0-100 scale" | Extract as `MIN_SENSITIVITY`, `MAX_SENSITIVITY` |
| 20 | `0` | Minimum sensitivity | No | `sensitivity 0 -> highest threshold` | Same as above |
| 21 | `100` | Maximum sensitivity | No | `sensitivity 100 -> lowest threshold` | Same as above |
| 22 | `100` | Default sensitivity | No | `Default sensitivity is 100` | Extract as `DEFAULT_SENSITIVITY` |
| 25 | `0`, `100` | Sensitivity range in mapping | No | `fun rmsThresholdFromSensitivity(sensitivity: Int)` | Already defined conceptually |
| 28 | `0`, `0.01`, `100`, `0.00055` | RMS threshold calculation | No | `0.01 - (sensitivity / 100.0) * 0.00945` | Extract as `MAX_RMS_THRESHOLD`, `RMS_THRESHOLD_SCALE` |
| 29 | `0.01`, `100.0`, `0.00945` | RMS threshold calculation | No | Implementation details | Extract as constants for formula |
| 34 | `0`, `0.1`, `100`, `0.8` | Clarity threshold calculation | No | `0.1 + (sensitivity / 100.0) * 0.7` | Extract as `MIN_CLARITY_THRESHOLD`, `CLARITY_THRESHOLD_SCALE`, `MAX_CLARITY_THRESHOLD` |
| 35 | `0.1`, `100.0`, `0.7` | Clarity threshold calculation | No | Implementation details | Extract as formula constants |
| 40 | `0`, `0.5`, `100`, `0.05` | Probability threshold calculation | No | `0.5f - (sensitivity / 100.0f) * 0.45f` | Extract as `MAX_PROBABILITY_THRESHOLD`, `PROBABILITY_THRESHOLD_SCALE`, `MIN_PROBABILITY_THRESHOLD` |
| 41 | `0`, `100`, `0` | Float conversion values | No | `0.5f`, `100.0f`, `0.45f` | Language syntax (acceptable) |
| 54 | `0.0` | Initial sum for RMS | No | `var sum = 0.0` | Use `INITIAL_SUM` constant |
| 86 | `0.0` | Invalid frequency return | No | `if (estimatedFrequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 91 | `80`, `1350` | Guitar frequency range | No | Comment: "80-1350 Hz" | Extract as `MIN_GUITAR_FREQUENCY`, `MAX_GUITAR_FREQUENCY` |
| 92 | `80.0`, `1350.0` | Guitar frequency validation | No | `estimatedFrequency < 80.0 || estimatedFrequency > 1350.0` | Same as above |
| 93 | `80`, `1350` | Log message values | No | `"Frequency out of guitar range (80-1350 Hz)"` | Already defined conceptually |
| 119 | `2` | Minimum buffer size for YIN | No | `if (audioData.size < 2)` | Extract as `MIN_YIN_BUFFER_SIZE` |
| 119 | `0.0` | Invalid return value | No | `return 0.0` | Use `INVALID_FREQUENCY` constant |
| 125 | `80.0` | Minimum frequency for YIN | No | `val minFreq = 80.0` | Already defined above |
| 126 | `1350.0` | Maximum frequency for YIN | No | `val maxFreq = 1350.0` | Already defined above |
| 127 | `33` | Approximate tau for 1350Hz | No | Comment: "~33 samples for 1350Hz" | Calculate dynamically |
| 128 | `2`, `551` | Tau calculations | No | `Math.min(buffer.size / 2, (sampleRate / minFreq).toInt())` | `2` could be `DIVISOR_FOR_HALF_BUFFER`, `551` is dynamic |
| 130 | `0.0` | Invalid return for condition | No | `if (tauMax <= tauMin) return 0.0` | Use `INVALID_FREQUENCY` |
| 132 | `440.0` | Expected tau calculation | No | `expected tau for 440Hz=${sampleRate/440.0}` | Could use `DEFAULT_REFERENCE_FREQUENCY` |
| 134 | `1` | Loop start index | No | `for (t in 0 until tauMax)` | Standard loop (acceptable) |
| 134 | `0` | Array initialization index | No | `val d = DoubleArray(tauMax)` | Standard initialization |
| 136 | `0` | Loop start for difference function | No | `for (t in 0 until tauMax)` | Standard loop |
| 137 | `0.0` | Initial sum for difference | No | `var sum = 0.0` | Use `INITIAL_SUM` |
| 138 | `0` | Inner loop start | No | `for (j in 0 until buffer.size - t)` | Standard loop |
| 145 | `2` | Divisor in mean calculation | No | `dPrime[t] = d[t] * t / runningSum` | Part of YIN algorithm (algorithmic constant) |
| 147 | `0` | First array index | No | `dPrime[0] = 1.0` | Standard array access |
| 147 | `1.0` | Initial dPrime value | No | `dPrime[0] = 1.0` | YIN algorithm constant |
| 148 | `0.0` | Initial running sum | No | `var runningSum = 0.0` | Use `INITIAL_SUM` |
| 150 | `1` | Loop start (skip index 0) | No | `for (t in 1 until tauMax)` | Standard loop |
| 153 | `0.0` | Zero check for division | No | `if (runningSum == 0.0)` | Use `ZERO` constant |
| 154 | `1.0` | Default dPrime for zero sum | No | `dPrime[t] = 1.0` | YIN algorithm constant |
| 160 | `3` | Loop variable in trough search | No | `for (t in tauMin until tauMax)` | Already uses tauMin |
| 161 | `0.1`, `0.2`, `0.08`, `0.25` | YIN threshold range | No | Comment: "Typical YIN threshold is 0.1-0.2" | Extract as `MIN_YIN_THRESHOLD`, `MAX_YIN_THRESHOLD`, `YIN_THRESHOLD_BASE`, `YIN_THRESHOLD_SCALE` |
| 162 | `0.08`, `0.2125` | Threshold calculation | No | `val threshold = 0.08 + clarityThreshold * 0.2125` | Extract as `YIN_THRESHOLD_OFFSET`, `YIN_THRESHOLD_MULTIPLIER` |
| 163 | `0` | Initial tau value | No | `var tau = 0` | Extract as `INITIAL_TAU` |
| 171 | `4` | Search range for global min | No | `for (t in tauMin until tauMax)` | Already uses tauMin |
| 172 | `0` | Loop variable reinitialization | No | Loop variable `t` | Standard loop |
| 182 | `0` | Check for valid tau | No | `if (tau > 0 && ...)` | Could use `INVALID_TAU` |
| 185 | `0` | Invalid return for unclear pitch | No | `return 0.0` | Use `INVALID_FREQUENCY` |
| 187 | `0.0` | Return value | No | `return 0.0` | Use `INVALID_FREQUENCY` |
| 190 | `5` | Parabolic interpolation check | No | `if (tau > tauMin && tau < tauMax - 1)` | `5` should be `1`? Needs review |
| 191 | `1` | Array bounds check | No | `tau < tauMax - 1` | Array bounds logic |
| 198 | `0.0` | Default frequency for invalid tau | No | `val freq = if (tau >= tauMin) ... else 0.0` | Use `INVALID_FREQUENCY` |
| 205 | `1` | Array offset for interpolation | No | `val s0 = data[tau - 1]` | Standard array access |
| 207 | `1` | Array offset for interpolation | No | `val s2 = data[tau + 1]` | Standard array access |
| 209 | `2.0`, `2.0` | Denominator calculation | No | `val denominator = 2.0 * (2.0 * s1 - s2 - s0)` | Parabolic formula constant |
| 212 | `10` | Small denominator threshold | No | `if (Math.abs(denominator) < 1e-10)` | Extract as `MIN_DENOMINATOR` |
| 227 | `0`, `100` | Sensitivity clamping range | No | `sensitivity.coerceIn(0, 100)` | Already defined as range constants |
| 228 | `0`, `100` | Same as above | No | `val clampedSensitivity = ...` | Already defined |
| 255 | `0.1` | Synthetic duration seconds | No | `val duration = 0.1 // 100ms` | Extract as `SYNTHETIC_DURATION_SECONDS` |
| 258 | `2.0` | PI multiplier for angular freq | No | `val angularFreq = 2.0 * Math.PI * frequency / sampleRate` | Standard formula (acceptable) |
| 259 | `0` | Loop start index | No | `for (i in 0 until samples)` | Standard loop |

**File Summary:** Contains 70 magic numbers, with only 3 already defined as named constants. Many represent pitch detection algorithm parameters that should be extracted for configurability.

### 4. `NoteFinder.kt` - Note frequency calculations

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 21 | `0.0` | Invalid frequency check | No | `if (frequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 22 | `0.0` | Default target frequency | No | `return NoteInfo("--", 0f, 0f, 0.0)` | Use `INVALID_FREQUENCY` |
| 26 | `12.0` | Semitones per octave | No | `12.0 * log2(frequency / referenceFrequency)` | Extract as `SEMITONES_PER_OCTAVE` |
| 32 | `100` | Cents per semitone | No | `((semitonesFromA4 - roundedSemitones) * 100).toFloat()` | Extract as `CENTS_PER_SEMITONE` |
| 34 | `9` | Note index offset for A | No | Comment: "A4 = index 9, since A is 9th note" | Extract as `A_NOTE_INDEX` |
| 35 | `9` | Same offset in calculation | No | `val noteIndex = ((9 + roundedSemitones) % 12 + 12) % 12` | Same as above |
| 36 | `9`, `12`, `12`, `12` | Note index modulo calculation | No | Same line as above | Already uses constants |
| 38 | `4` | A4 octave number | No | Comment: "A4 is octave 4" | Extract as `A4_OCTAVE` |
| 39 | `4`, `9`, `12` | Octave calculation | No | `val octave = 4 + (roundedSemitones + 9) / 12` | Uses above constants |
| 44 | `2.0`, `12.0` | Frequency calculation | No | `referenceFrequency * Math.pow(2.0, roundedSemitones / 12.0)` | Extract as `FREQUENCY_RATIO_BASE`, `SEMITONES_PER_OCTAVE` |
| 46 | `0` | Minimum probability clamp | No | `.coerceIn(0f, 1f)` | Standard clamp (acceptable) |
| 47 | `1`, `50` | Probability calculation | No | `1.0f - (Math.abs(cents) / 50.0f).coerceIn(0f, 1f)` | Extract as `MAX_PROBABILITY`, `MAX_CENTS_FOR_PROBABILITY` |
| 55 | `12` | Notes per octave constant | Yes | `private const val NOTES_PER_OCTAVE = 12` | Already properly defined |
| 58 | `0.0`, `0.0` | Invalid frequency checks | No | `if (frequency <= 0.0 || targetFrequency <= 0.0)` | Use `INVALID_FREQUENCY` |
| 59 | `1200.0` | Cents conversion factor | No | `(1200.0 * log2(frequency / targetFrequency)).toFloat()` | Extract as `CENTS_PER_OCTAVE` |
| 63 | `2.0`, `1200.0` | Frequency ratio from cents | No | `Math.pow(2.0, cents / 1200.0)` | Same constants as above |

**File Summary:** Contains 20 magic numbers, with 1 already defined as a named constant. Many represent musical theory constants that should be extracted.

### 5. `SettingsDialog.kt` - User interface settings

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 30 | `50` | Default sensitivity | No | `sensitivity: Int = 50` | Extract as `DEFAULT_SENSITIVITY` |
| 31 | `1000` | Default display delay (ms) | No | `displayDelayMs: Long = 1000` | Extract as `DEFAULT_DISPLAY_DELAY_MS` |
| 32 | `200` | Default pitch update delay (ms) | No | `pitchUpdateDelayMs: Long = 200` | Extract as `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 74 | `50` | Current sensitivity initial value | No | `private var currentSensitivity = 50` | Use `DEFAULT_SENSITIVITY` |
| 75 | `1000` | Current display delay initial value | No | `private var currentDisplayDelayMs = 1000L` | Use `DEFAULT_DISPLAY_DELAY_MS` |
| 76 | `200` | Current pitch update delay initial value | No | `private var currentPitchUpdateDelayMs = 200L` | Use `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 82 | `50` | Default sensitivity from bundle | No | `it.getInt(ARG_SENSITIVITY, 50)` | Use `DEFAULT_SENSITIVITY` |
| 83 | `1000` | Default display delay from bundle | No | `it.getLong(ARG_DISPLAY_DELAY_MS, 1000)` | Use `DEFAULT_DISPLAY_DELAY_MS` |
| 84 | `200` | Default pitch update delay from bundle | No | `it.getLong(ARG_PITCH_UPDATE_DELAY_MS, 200)` | Use `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 126 | `430`, `2` | Frequency seekbar calculation | No | `((currentFrequency - 430) * 2).roundToInt()` | Extract as `MIN_REFERENCE_FREQUENCY`, `FREQUENCY_SCALE_FACTOR` |
| 132 | `0`, `1000` | Display delay range comment | No | Comment: "Display delay: 0-1000 ms" | Extract as `MIN_DISPLAY_DELAY_MS`, `MAX_DISPLAY_DELAY_MS` |
| 136 | `0`, `1000` | Pitch update delay range comment | No | Comment: "Pitch update delay: 0-1000 ms" | Extract as `MIN_PITCH_UPDATE_DELAY_MS`, `MAX_PITCH_UPDATE_DELAY_MS` |
| 153 | `430`, `2.0` | Frequency from seekbar progress | No | `currentFrequency = 430 + (progress / 2.0)` | Same constants as above |
| 218 | `430.0`, `450.0` | Frequency validation range | No | `if (newFrequency in 430.0..450.0)` | Extract as `MIN_REFERENCE_FREQUENCY`, `MAX_REFERENCE_FREQUENCY` |
| 220 | `430`, `2` | Seekbar update calculation | No | `((newFrequency - 430) * 2).roundToInt()` | Same constants as above |
| 232 | `430.0`, `450.0` | Frequency clamping range | No | `frequency.coerceIn(430.0, 450.0)` | Same constants as above |
| 236 | `0`, `100` | Sensitivity clamping range | No | `sensitivity.coerceIn(0, 100)` | Extract as `MIN_SENSITIVITY`, `MAX_SENSITIVITY` |

**File Summary:** Contains 20 magic numbers, none defined as named constants. All represent UI configuration parameters that should be extracted.

### 6. `FrequencyUtils.kt` - Frequency utility functions

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 8 | `440.0` | A4 reference frequency | Yes | `private const val A4_FREQUENCY = 440.0` | Already properly defined |
| 9 | `12` | Notes per octave | Yes | `private const val NOTES_PER_OCTAVE = 12` | Already properly defined |
| 16 | `0.0` | Invalid frequency check | No | `if (frequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 16 | `0` | Default semitone return | No | `return Pair("--", 0)` | Extract as `INVALID_SEMITONE` |
| 18 | `12.0` | Semitones per octave | No | `12.0 * log2(frequency / referenceFrequency)` | Use `NOTES_PER_OCTAVE` constant |
| 21 | `12`, `12`, `12` | Note index modulo calculation | No | `((roundedSemitones % 12 + 12) % 12)` | Use `NOTES_PER_OCTAVE` constant |
| 22 | `4`, `9`, `12` | Octave calculation | No | `4 + (roundedSemitones + 9) / 12` | Extract as `A4_OCTAVE`, `A_NOTE_INDEX`, `NOTES_PER_OCTAVE` |
| 29 | `0.0`, `0.0` | Invalid frequency checks | No | `if (frequency <= 0.0 || targetFrequency <= 0.0)` | Use `INVALID_FREQUENCY` |
| 30 | `1200.0` | Cents per octave | No | `(1200.0 * log2(frequency / targetFrequency)).toFloat()` | Extract as `CENTS_PER_OCTAVE` |
| 34 | `2.0`, `12.0` | Frequency calculation | No | `referenceFrequency * 2.0.pow(semitonesFromA4 / 12.0)` | Extract as `FREQUENCY_RATIO_BASE`, use `NOTES_PER_OCTAVE` |
| 38 | `12`, `12`, `12` | Note name index calculation | No | `noteNames[(index % 12 + 12) % 12]` | Use `NOTES_PER_OCTAVE` constant |
| 44 | `6` | Number of octaves to generate | No | Comment: "Generate frequencies for 6 octaves (C2 to B7)" | Extract as `OCTAVES_TO_GENERATE` |
| 45 | `2`, `7` | Octave range for generation | No | `for (octave in 2..7)` | Extract as `MIN_GENERATED_OCTAVE`, `MAX_GENERATED_OCTAVE` |
| 47 | `9`, `4`, `12` | Semitone calculation | No | `noteIndex - 9 + (octave - 4) * 12` | Extract as `A_NOTE_INDEX`, `A4_OCTAVE`, `NOTES_PER_OCTAVE` |
| 70 | `0`, `0.5`, `0.5` | Rounding helper function | No | `if (this >= 0) (this + 0.5).toInt() else (this - 0.5).toInt()` | Extract as `ROUNDING_OFFSET` |

**File Summary:** Contains 23 magic numbers, with 2 already defined as named constants. Many duplicate constants from other files.

### 7. `AudioTestUtils.kt` - Audio testing utilities

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 9 | `1000` | Default sine wave duration (ms) | No | `durationMs: Int = 1000` | Extract as `DEFAULT_SINE_DURATION_MS` |
| 11 | `1000` | Milliseconds per second | No | `(durationMs * sampleRate) / 1000` | Extract as `MILLISECONDS_PER_SECOND` |
| 14 | `2.0` | PI multiplier for angular frequency | No | `2.0 * PI * frequency / sampleRate` | Standard formula (acceptable) |
| 25 | `1` | Duration in seconds comment | No | Comment: "1 second" | Could use constant |
| 29 | `2.0` | PI multiplier for angular frequency | No | `2.0 * PI * fundamental / sampleRate` | Same as above |
| 32 | `1.0`, `0.5`, `0.3`, `0.2`, `0.1` | Harmonic amplitude ratios | No | `listOf(1.0, 0.5, 0.3, 0.2, 0.1)` | Extract as `HARMONIC_AMPLITUDES` array |
| 35 | `0.0` | Initial sample value | No | `var sample = 0.0` | Use `INITIAL_SAMPLE` constant |
| 42 | `2` | Harmonic multiplier offset | No | `fundamental * (harmonicIndex + 2)` | Extract as `HARMONIC_MULTIPLIER_OFFSET` |
| 43 | `2.0` | PI multiplier for harmonic | No | `2.0 * PI * harmonicFreq / sampleRate` | Standard formula |
| 48 | `2.0` | Normalization divisor | No | `(sample / 2.0).toFloat()` | Extract as `NORMALIZATION_FACTOR` |
| 56-61 | `82.41`, `110.0`, `146.83`, `196.0`, `246.94`, `329.63` | Guitar string frequencies | No | Standard guitar tuning frequencies | Extract as named constants |
| 67 | `0.1` | Default noise level | No | `noiseLevel: Float = 0.1f` | Extract as `DEFAULT_NOISE_LEVEL` |
| 69 | `2`, `1` | Noise generation range | No | `(Math.random() * 2 - 1) * noiseLevel` | Extract as `NOISE_RANGE_MULTIPLIER`, `NOISE_RANGE_OFFSET` |
| 81-86 | Same as 56-61 | Guitar tuning frequencies | No | `GUITAR_STANDARD_TUNING` map | Already defined as map values |
| 90-92 | Various | Note frequencies for different octaves | No | Map of note frequencies | Could extract but these are reference data |

**File Summary:** Contains 26 magic numbers, none defined as named constants. Many represent test audio generation parameters.

### 8. `MainActivity.kt` - Main application activity

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 38 | `0` | Initial activity start time | No | `private var activityStartTime: Long = 0` | Use `INITIAL_TIME` constant |
| 40 | `0.0` | Initial RMS value | No | `private var currentRms = 0.0` | Use `INITIAL_RMS` constant |
| 42 | `0` | Initial null reads counter | No | `private var consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 43 | `10` | Maximum consecutive null reads | Yes | `private val MAX_CONSECUTIVE_NULL_READS = 10` | Already properly defined |
| 45 | `0` | Initial valid pitch time | No | `private var lastValidPitchTime: Long = 0` | Use `INITIAL_TIME` |
| 52 | `0` | Initial pitch update time | No | `private var lastPitchUpdateTime: Long = 0` | Use `INITIAL_TIME` |
| 56 | `1001` | Audio permission request code | Yes | `private const val AUDIO_PERMISSION_REQUEST_CODE = 1001` | Already properly defined |
| 58 | `100` | Default sensitivity | Yes | `private const val DEFAULT_SENSITIVITY = 100` | Already properly defined |
| 113 | `0` | Reset valid pitch time | No | `lastValidPitchTime = 0` | Use `INITIAL_TIME` |
| 114 | `0` | Reset pitch update time | No | `lastPitchUpdateTime = 0` | Use `INITIAL_TIME` |
| 115 | `0` | Reset null reads counter | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 121 | `0` | Loop iteration counter | No | `var iteration = 0` | Standard variable initialization |
| 124 | `10`, `20`, `100`, `0` | Debug logging thresholds | No | `iteration <= 10 || iteration % 20 == 0 || iteration % 100 == 0` | Extract as `INITIAL_DEBUG_THRESHOLD`, `DEBUG_MODULUS_1`, `DEBUG_MODULUS_2` |
| 137 | `0.0` | Reset RMS value | No | `currentRms = 0.0` | Use `INITIAL_RMS` |
| 141 | `0` | Reset null reads | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 192 | `50` | Loop delay in milliseconds | No | `delay(50) // Update ~20 times per second` | Extract as `TUNING_LOOP_DELAY_MS` |
| 212 | `0` | Reset valid pitch time in stop | No | `lastValidPitchTime = 0` | Use `INITIAL_TIME` |
| 213 | `0` | Reset pitch update time in stop | No | `lastPitchUpdateTime = 0` | Use `INITIAL_TIME` |
| 217 | `0.0` | Reset RMS in stop | No | `currentRms = 0.0` | Use `INITIAL_RMS` |
| 235 | `0` | Reset null reads on restart | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 248 | `0.0` | Initial sum for RMS | No | `var sum = 0.0` | Use `INITIAL_SUM` |
| 258 | `0` | Cents comparison for display | No | `if (result.cents > 0)` | Could use `ZERO_CENTS` |
| 267 | `5` | In-tune threshold in cents | No | `absCents < 5` | Extract as `IN_TUNE_THRESHOLD_CENTS` |
| 268 | `0` | Cents comparison for sharp | No | `result.cents > 0` | Could use `ZERO_CENTS` |
| 334 | `0` | Array index for permission result | No | `grantResults[0]` | Standard array access |
| 372 | `2000` | Minimum activity lifetime (ms) | No | `if (elapsed < 2000)` | Extract as `MIN_ACTIVITY_LIFETIME_MS` |

**File Summary:** Contains 26 magic numbers, with 3 already defined as named constants. Many represent timing and threshold values.

---

## Python Files Analysis

### 1. `tools/generate_icon.py` - Original detailed icon generation

**Note:** Python icon generation scripts contain many geometric and scaling constants. While these are technically "magic numbers," they are often acceptable in graphics generation code where they represent visual proportions rather than business logic. However, key dimensions should still be extracted.

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 11 | `512` | Base icon size | No | `size=512` | Extract as `BASE_ICON_SIZE` |
| 19, 20 | `2` | Center calculation divisions | No | `size // 2` repeated | Could use `HALF_DIVISOR` |
| 21 | `0.8` | Icon size relative to canvas | No | `icon_size = size * 0.8` | Extract as `ICON_CANVAS_RATIO` |
| 25 | `0.7` | Headstock width ratio | No | `headstock_width = icon_size * 0.7` | Extract as `HEADSTOCK_WIDTH_RATIO` |
| 26 | `0.6` | Headstock height ratio | No | `headstock_height = icon_size * 0.6` | Extract as `HEADSTOCK_HEIGHT_RATIO` |
| 27-30 | `2` | Various center calculations | No | Multiple `// 2` operations | Could use `HALF_DIVISOR` |
| 35 | `0.5` | Bottom width ratio | No | `bottom_width = headstock_width * 0.5` | Extract as `HEADSTOCK_BOTTOM_RATIO` |
| 38-41 | `2` | Division operations | No | Multiple `// 2` operations | Already covered |
| 47 | `6`, `3` | Number of tuning pegs | No | Comment: "6 total, 3 on each side" | Extract as `TOTAL_PEGS`, `PEGS_PER_SIDE` |
| 48 | `0.04` | Peg radius ratio | No | `peg_radius = icon_size * 0.04` | Extract as `PEG_RADIUS_RATIO` |
| 49 | `0.25` | Peg spacing ratio | No | `peg_spacing = headstock_height * 0.25` | Extract as `PEG_SPACING_RATIO` |
| 52 | `3` | Loop for pegs per side | No | `for i in range(3):` | Use `PEGS_PER_SIDE` |
| 53 | `1` | Y-position offset | No | `(i + 1) * peg_spacing` | Standard loop offset |
| 54 | `0.15` | Peg X-position offset | No | `headstock_left + headstock_width * 0.15` | Extract as `PEG_X_OFFSET_RATIO` |
| 64 | `2` | Outline width for peg | No | `width=2` | Extract as `PEG_OUTLINE_WIDTH` |
| 68 | `3` | Line length multiplier | No | `x_pos + peg_radius * 3` | Extract as `PEG_LINE_MULTIPLIER` |
| 70 | `2` | Line width | No | `width=2` | Same as outline width |
| 74 | `3` | Right side pegs loop | No | `for i in range(3):` | Use `PEGS_PER_SIDE` |
| 75 | `1` | Y-position offset | No | `(i + 1) * peg_spacing` | Standard loop offset |
| 76 | `0.15` | Peg X-position offset | No | `headstock_right - headstock_width * 0.15` | Same as left side |
| 86 | `2` | Outline width | No | `width=2` | Already defined |
| 90 | `3` | Line length multiplier | No | `x_pos - peg_radius * 3` | Same as left side |
| 92 | `2` | Line width | No | `width=2` | Already defined |
| 97 | `0.15` | Note size ratio | No | `note_size = icon_size * 0.15` | Extract as `NOTE_SIZE_RATIO` |
| 99 | `0.2` | Note Y-offset ratio | No | `note_y = center_y - note_size * 0.2` | Extract as `NOTE_Y_OFFSET_RATIO` |
| 102 | `0.5` | Note head width ratio | No | `note_head_width = note_size * 0.5` | Extract as `NOTE_HEAD_WIDTH_RATIO` |
| 103 | `0.3` | Note head height ratio | No | `note_head_height = note_size * 0.3` | Extract as `NOTE_HEAD_HEIGHT_RATIO` |
| 106-109 | `2` | Division operations | No | Multiple `// 2` operations | Already covered |
| 115 | `0.6` | Stem length ratio | No | `stem_length = note_size * 0.6` | Extract as `STEM_LENGTH_RATIO` |
| 116 | `0.1` | Stem width ratio | No | `stem_width = note_size * 0.1` | Extract as `STEM_WIDTH_RATIO` |
| 117 | `2` | Stem X-position calculation | No | `stem_x = note_x + note_head_width // 2 - stem_width // 2` | Uses division constants |
| 123 | `0.3` | Flag size ratio | No | `flag_size = note_size * 0.3` | Extract as `FLAG_SIZE_RATIO` |
| 124 | `5` | Number of flag elements | No | `for i in range(5):` | Extract as `FLAG_ELEMENT_COUNT` |
| 125 | `10` | Flag Y-position divisor | No | `i * flag_size / 10` | Extract as `FLAG_Y_DIVISOR` |
| 126 | `15` | Flag X-position divisor | No | `i * flag_size / 15` | Extract as `FLAG_X_DIVISOR` |
| 129 | `10`, `20` | Flag ellipse dimensions | No | `flag_size / 10`, `flag_size / 20` | Use ratios from above |
| 132 | `20` | Flag ellipse dimension | No | `flag_size / 20` | Already covered |
| 144 | `512` | Icon size for generation | No | `create_guitar_tuner_icon(512)` | Use `BASE_ICON_SIZE` |
| 151 | `0`, `1` | Image size tuple indices | No | `icon.size[0]`, `icon.size[1]` | Standard tuple access |
| 155 | `192` | Small icon size | No | `create_guitar_tuner_icon(192)` | Extract as `SMALL_ICON_SIZE` |

**File Summary:** Contains 40 magic numbers (many repeated), none defined as named constants. While many are geometric ratios acceptable in graphics code, key dimensions should be extracted.

### 2. `tools/generate_simple_icon.py` - Simplified icon generation

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 10 | `512` | Base icon size | No | `size=512` | Extract as `BASE_ICON_SIZE` |
| 18, 19 | `2` | Center calculations | No | Multiple `// 2` operations | Could use `HALF_DIVISOR` |
| 20 | `0.8` | Icon size ratio | No | `icon_size = size * 0.8` | Extract as `ICON_CANVAS_RATIO` |
| 23 | `0.7` | Headstock width ratio | No | `headstock_width = icon_size * 0.7` | Extract as `HEADSTOCK_WIDTH_RATIO` |
| 24 | `0.6` | Headstock height ratio | No | `headstock_height = icon_size * 0.6` | Extract as `HEADSTOCK_HEIGHT_RATIO` |
| 28, 29 | `2` | Rectangle coordinate calculations | No | Multiple `// 2` operations | Already covered |
| 32 | `0.1` | Corner radius ratio | No | `corner_radius = headstock_width * 0.1` | Extract as `CORNER_RADIUS_RATIO` |
| 38 | `2` | Outline width | No | `width=2` | Extract as `OUTLINE_WIDTH` |
| 41 | `6` | Total tuning pegs | No | Comment: "Draw tuning pegs (6 total)" | Extract as `TOTAL_PEGS` |
| 42 | `0.035` | Peg radius ratio | No | `peg_radius = icon_size * 0.035` | Extract as `PEG_RADIUS_RATIO` |
| 43 | `0.25` | Peg spacing ratio | No | `peg_spacing = headstock_height * 0.25` | Extract as `PEG_SPACING_RATIO` |
| 46 | `3` | Pegs per side | No | `for i in range(3):` | Extract as `PEGS_PER_SIDE` |
| 47 | `2`, `1` | Y-position calculation | No | `center_y - headstock_height // 2 + (i + 1) * peg_spacing` | Uses existing constants |
| 48 | `2`, `0.2` | X-position calculation | No | `center_x - headstock_width // 2 + headstock_width * 0.2` | Extract as `LEFT_PEG_X_OFFSET_RATIO` |
| 60 | `3` | Right side pegs loop | No | `for i in range(3):` | Use `PEGS_PER_SIDE` |
| 61 | `2`, `1` | Y-position calculation | No | Similar to left side | Uses existing constants |
| 62 | `2`, `0.2` | X-position calculation | No | `center_x + headstock_width // 2 - headstock_width * 0.2` | Extract as `RIGHT_PEG_X_OFFSET_RATIO` |
| 74 | `0.3` | Tuning line length ratio | No | `line_length = headstock_width * 0.3` | Extract as `TUNING_LINE_LENGTH_RATIO` |
| 78 | `2`, `0.35` | Left line X-position | No | `center_x - headstock_width // 2 + headstock_width * 0.35` | Extract as `LEFT_LINE_X_OFFSET_RATIO` |
| 83 | `0.03` | Line width ratio | No | `width=int(icon_size * 0.03)` | Extract as `TUNING_LINE_WIDTH_RATIO` |
| 87 | `2`, `0.35` | Right line X-position | No | `center_x + headstock_width // 2 - headstock_width * 0.35` | Extract as `RIGHT_LINE_X_OFFSET_RATIO` |
| 92 | `0.03` | Line width ratio | No | Same as left line | Already defined |
| 97 | `0.12` | Note size ratio | No | `note_size = icon_size * 0.12` | Extract as `NOTE_SIZE_RATIO` |
| 104 | `0.2` | Note head width | No | `note_x - note_size * 0.2` | Extract as `NOTE_HEAD_WIDTH_RATIO` |
| 105 | `0.1` | Note head height | No | `note_y - note_size * 0.1` | Extract as `NOTE_HEAD_HEIGHT_RATIO` |
| 106 | `0.2` | Note head width | No | `note_x + note_size * 0.2` | Already covered |
| 107 | `0.1` | Note head height | No | `note_y + note_size * 0.1` | Already covered |
| 113 | `0.4` | Stem length ratio | No | `stem_length = note_size * 0.4` | Extract as `STEM_LENGTH_RATIO` |
| 116 | `0.15`, `2` | Stem X-position | No | `note_x + note_size * 0.15` | Extract as `STEM_X_OFFSET_RATIO` |
| 117 | `2`, `0.25` | Stem X-end position | No | `note_x + note_size * 0.25` | Extract as `STEM_END_X_RATIO` |
| 118 | `2` | Stem Y-position division | No | `note_y - stem_length // 2` | Uses existing constant |
| 119 | `2` | Stem Y-end division | No | `note_y + stem_length // 2` | Uses existing constant |
| 127 | `512` | Tuning fork icon size | No | `create_tuning_fork_icon(512)` | Use `BASE_ICON_SIZE` |
| 133, 134 | `2` | Center calculations | No | `size // 2` repeated | Already covered |
| 135 | `0.7` | Icon size ratio | No | `icon_size = size * 0.7` | Extract as `FORK_ICON_SIZE_RATIO` |
| 138 | `0.3` | Fork width ratio | No | `fork_width = icon_size * 0.3` | Extract as `FORK_WIDTH_RATIO` |
| 139 | `0.6` | Fork height ratio | No | `fork_height = icon_size * 0.6` | Extract as `FORK_HEIGHT_RATIO` |
| 140 | `0.08` | Fork thickness ratio | No | `fork_thickness = icon_size * 0.08` | Extract as `FORK_THICKNESS_RATIO` |
| 143, 144 | `2` | Prong X-position calculations | No | Multiple `// 2` operations | Already covered |
| 149-152 | `2` | Rectangle coordinate calculations | No | Multiple `// 2` operations | Already covered |
| 160-163 | `2` | Right prong coordinates | No | Similar to left prong | Already covered |
| 172-174 | `2` | Handle coordinates | No | Multiple calculations | Already covered |
| 180 | `1.5` | Base width multiplier | No | `base_width = fork_width * 1.5` | Extract as `BASE_WIDTH_MULTIPLIER` |
| 181 | `1.5` | Base height multiplier | No | `base_height = fork_thickness * 1.5` | Extract as `BASE_HEIGHT_MULTIPLIER` |
| 184-187 | `2` | Base coordinates | No | Multiple `// 2` operations | Already covered |
| 193 | `0.15` | Note size ratio | No | `note_size = icon_size * 0.15` | Extract as `FORK_NOTE_SIZE_RATIO` |
| 195 | `2` | Note Y-position calculation | No | `center_y - fork_height // 2 - fork_thickness - note_size` | Uses existing constants |
| 200 | `0.25` | Note head width ratio | No | `note_x - note_size * 0.25` | Extract as `FORK_NOTE_HEAD_WIDTH_RATIO` |
| 201 | `0.15` | Note head height ratio | No | `note_y - note_size * 0.15` | Extract as `FORK_NOTE_HEAD_HEIGHT_RATIO` |
| 202 | `0.25` | Note head width | No | `note_x + note_size * 0.25` | Already covered |
| 203 | `0.15` | Note head height | No | `note_y + note_size * 0.15` | Already covered |
| 209 | `0.5` | Stem length ratio | No | `stem_length = note_size * 0.5` | Extract as `FORK_STEM_LENGTH_RATIO` |
| 212 | `0.2` | Stem X-start ratio | No | `note_x + note_size * 0.2` | Extract as `FORK_STEM_X_OFFSET_RATIO` |
| 214 | `0.3` | Stem X-end ratio | No | `note_x + note_size * 0.3` | Extract as `FORK_STEM_END_X_RATIO` |
| 230 | `1` | Default selection index | No | `selection = "1"` | Extract as `DEFAULT_SELECTION` |
| 231 | `512` | Simple icon size | No | `create_simple_headstock_icon(512)` | Use `BASE_ICON_SIZE` |
| 235 | `2` | Include note parameter | No | `include_note=False` | Extract as `DEFAULT_INCLUDE_NOTE` |
| 236 | `512` | Note icon size | No | `create_simple_headstock_icon(512)` | Use `BASE_ICON_SIZE` |
| 240 | `3` | Tuning fork selection | No | `print("3. Generating tuning fork icon...")` | UI constant |
| 241 | `512` | Tuning fork size | No | `create_tuning_fork_icon(512)` | Use `BASE_ICON_SIZE` |
| 245 | `4` | Android launcher step | No | `print("4. Generating Android launcher sizes...")` | UI constant |
| 247-249 | `192` | Android icon sizes | No | `create_simple_headstock_icon(192)` x3 | Extract as `ANDROID_LAUNCHER_SIZE` |

**File Summary:** Contains 61 magic numbers (many repeated), none defined as named constants. Similar to the first icon script, geometric ratios dominate.

### 3. `tools/generate_android_icons.py` - Android density-specific icon generation

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 13 | `1.0` | MDPI scale factor | No | `"mdpi": 1.0` | Part of `DENSITY_BUCKETS` dict |
| 14 | `1.5` | HDPI scale factor | No | `"hdpi": 1.5` | Part of `DENSITY_BUCKETS` dict |
| 15 | `2.0` | XHDPI scale factor | No | `"xhdpi": 2.0` | Part of `DENSITY_BUCKETS` dict |
| 16 | `3.0` | XXHDPI scale factor | No | `"xxhdpi": 3.0` | Part of `DENSITY_BUCKETS` dict |
| 17 | `4.0` | XXXHDPI scale factor | No | `"xxxhdpi": 4.0` | Part of `DENSITY_BUCKETS` dict |
| 21 | `48` | Launcher icon size in dp | No | `LAUNCHER_ICON_SIZE_DP = 48` | Extract as constant |
| 47 | `50` | Print separator length | No | `print("=" * 50)` | UI formatting constant |
| 74 | `24` | Notification icon size in dp | No | `notif_size = int(24 * scale_factor)` | Extract as `NOTIFICATION_ICON_SIZE_DP` |

**File Summary:** Contains 8 magic numbers, none defined as named constants. These are Android platform constants that should be extracted.

---

## Recommendations and Action Plan

### High Priority (Business Logic & Configuration)
1. **Audio constants** in `AudioConfig.kt` are well-defined, but duplicates exist elsewhere
2. **Musical constants** (12 semitones/octave, 1200 cents/octave, A4=440Hz) should be centralized
3. **Threshold values** for pitch detection should be configurable constants
4. **UI timing values** (delays, sensitivities) should be in a configuration class

### Medium Priority (Algorithm Parameters)
1. **YIN algorithm constants** should be extracted with descriptive names
2. **Guitar frequency range** (80-1350Hz) should be constants
3. **Reference frequency tuning range** (430-450Hz) should be constants

### Low Priority (Graphics & Utilities)
1. **Icon generation ratios** are acceptable as-is for most cases
2. **Loop indices and simple arithmetic** (0, 1, 2) are generally acceptable
3. **Test data constants** (guitar tuning frequencies) could remain as-is

### Implementation Strategy

1. **Create a `Constants.kt` file** for shared musical/audio constants
2. **Create a `Config.kt` file** for tunable parameters
3. **Update existing files** to use these constants
4. **For Python scripts**, consider creating a `constants.py` if scripts grow more complex

### Immediate Actions

Based on frequency of use and impact:

1. Extract `SEMITONES_PER_OCTAVE = 12` and `CENTS_PER_OCTAVE = 1200` to shared constants
2. Extract `MIN_GUITAR_FREQUENCY = 80.0` and `MAX_GUITAR_FREQUENCY = 1350.0`
3. Extract `MIN_SENSITIVITY = 0` and `MAX_SENSITIVITY = 100`
4. Extract `DEFAULT_SENSITIVITY = 100` (currently differs between files)
5. Extract all timing constants (`DEFAULT_DISPLAY_DELAY_MS`, etc.)

### Files Requiring Most Attention

1. `PitchDetector.kt` - 70 magic numbers, only 3 named
2. `tools/generate_simple_icon.py` - 61 magic numbers, none named  
3. `tools/generate_icon.py` - 40 magic numbers, none named
4. `FrequencyUtils.kt` - 23 magic numbers, duplicates musical constants

---

## Conclusion

This codebase contains **187 magic numbers** across 11 files, with only **18 already defined as named constants**. While not all numeric literals require extraction (simple indices, loop variables, etc.), the majority represent important configuration values that should be named for clarity and maintainability.

The highest value improvements would be:
1. Centralizing musical theory constants
2. Making audio processing parameters configurable
3. Standardizing UI timing values
4. Documenting pitch detection algorithm parameters

Extracting these magic numbers will make the code more readable, easier to modify, and less prone to errors from inconsistent values across the codebase.

**Generated by opencode analysis on 2026-01-29**