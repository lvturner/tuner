# Magic Numbers Analysis Report (Kotlin Only)

**Project:** Guitar Tuner Android Application  
**Date:** January 29, 2026  
**Generated by:** opencode analysis

## Summary

This report identifies and documents all numeric literals ("magic numbers") in the Kotlin codebase. Magic numbers are hard-coded numeric values that lack clear semantic meaning and should typically be replaced with named constants for improved code maintainability, readability, and ease of modification.

### Overall Statistics

| Language | Files Analyzed | Magic Numbers Found | Already Named | Should Be Extracted |
|----------|---------------|---------------------|---------------|---------------------|
| Kotlin   | 8             | 155                 | 18            | 137                 |
| **Total** | **8**        | **155**             | **18**        | **137**             |

### Key Categories of Magic Numbers

1. **Audio Processing Constants**: Sample rates, buffer sizes, frequency thresholds
2. **Musical Constants**: Reference frequencies, note calculations, cent conversions
3. **UI/UX Constants**: Timing delays, sensitivity ranges, slider boundaries
4. **Algorithm Parameters**: Pitch detection thresholds, YIN algorithm constants

---

## Kotlin Files Analysis

### 1. `AudioRecorder.kt` - Audio recording configuration

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 16 | `0` | Initial read counter value | No | `readCounter = 0` | Extract as `INITIAL_READ_COUNTER` |
| 20 | `44100` | Audio sample rate | Yes | `SAMPLE_RATE = 44100` | Already properly defined |
| 23 | `4096` | Default buffer size in bytes | Yes | `BUFFER_SIZE_BYTES = 4096` | Already properly defined |
| 42 | `16` | Bits per sample | No | Comment: "16-bit samples" | Extract as `BITS_PER_SAMPLE` |
| 43 | `2` | Bytes per short | No | Division for buffer size conversion | Extract as `BYTES_PER_SHORT` |
| 54 | `2` | Buffer size multiplier | No | `minBufferSizeBytes * 2` | Extract as `BUFFER_SIZE_MULTIPLIER` |
| 61 | `2` | Buffer size multiplier | No | `minBufferSizeBytes * 2` | Extract as `BUFFER_SIZE_MULTIPLIER` |
| 65 | `1` | AudioRecord initialized state | No | Comment: "(1=initialized)" | Extract as `AUDIO_RECORD_INITIALIZED` |
| 74 | `3` | AudioRecord recording state | No | Comment: "(3=recording)" | Extract as `AUDIO_RECORD_RECORDING` |
| 76 | `2` | Buffer size multiplier | No | `${minBufferSizeBytes * 2}` | Already defined above |
| 101 | `0` | Buffer read start offset | No | `audioRecord.read(buffer, 0, ...)` | Extract as `BUFFER_READ_OFFSET` |
| 103 | `0` | Comparison for empty read | No | `bytesRead <= 0` | Use `NO_DATA_READ` constant |
| 109 | `10` | Logging threshold for initial reads | No | `readCounter <= 10` | Extract as `INITIAL_LOG_THRESHOLD` |
| 109 | `20` | Logging frequency modulus | No | `readCounter % 20 == 0` | Extract as `LOG_FREQUENCY_MODULUS` |
| 112 | `0.0` | Initial sum for RMS calculation | No | `var sum = 0.0` | Use `INITIAL_SUM` constant |
| 113 | `0` | Initial max amplitude | No | `var maxAbs = 0` | Use `INITIAL_MAX_AMPLITUDE` |
| 114 | `0.0` | Initial sum of squares | No | `var sumSquares = 0.0` | Use `INITIAL_SUM_SQUARES` |
| 115 | `0` | Loop start index | No | `for (i in 0 until bytesRead)` | Standard loop idiom (acceptable) |
| 129 | `5` | Number of samples to log | No | Comment: "Log first 5 samples" | Extract as `SAMPLES_TO_LOG` |
| 130 | `5` | Minimum samples for logging | No | `bytesRead >= 5` | Same as above |
| 131 | `0`, `1`, `2`, `3`, `4` | Sample indices to log | No | `buffer[0]`, `buffer[1]`, etc. | Use loop instead of hardcoded indices |
| 136 | `0` | Loop start for conversion | No | `for (i in 0 until bytesRead)` | Standard loop idiom (acceptable) |

**File Summary:** Contains 22 magic numbers, with 2 already defined as named constants (`SAMPLE_RATE`, `BUFFER_SIZE_BYTES`). Most represent audio processing parameters that should be extracted.

### 2. `AudioConfig.kt` - Audio configuration constants

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 4 | `44100` | Audio sample rate | Yes | `SAMPLE_RATE = 44100` | Already properly defined |
| 5 | `4096` | Buffer size in bytes | Yes | `BUFFER_SIZE = 4096` | Already properly defined |
| 6 | `440.0` | Reference frequency (A4) | Yes | `DEFAULT_REFERENCE_FREQUENCY = 440.0` | Already properly defined |
| 7 | `50.0` | Maximum cents deviation | Yes | `MAX_CENTS_DEVIATION = 50.0` | Already properly defined |
| 7 | `50` | Integer version of above | No | Same line as `50.0` | Already covered by constant |

**File Summary:** This file is well-structured with named constants. Only one redundant integer literal found.

### 3. `PitchDetector.kt` - Pitch detection algorithm

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 12 | `0.0005` | Default minimum RMS threshold | Yes | `DEFAULT_MIN_RMS_THRESHOLD = 0.0005` | Already properly defined |
| 12 | `0.05` | Percentage comment value | No | Comment: "0.05% of max amplitude" | Could extract as `PERCENTAGE_THRESHOLD` |
| 13 | `0.8` | Default clarity threshold | Yes | `DEFAULT_CLARITY_THRESHOLD = 0.8` | Already properly defined |
| 14 | `0` | Float literal suffix | No | `0.05f` formatting | Language syntax (acceptable) |
| 18 | `0`, `100` | Sensitivity range bounds | No | Comment: "0-100 scale" | Extract as `MIN_SENSITIVITY`, `MAX_SENSITIVITY` |
| 20 | `0` | Minimum sensitivity | No | `sensitivity 0 -> highest threshold` | Same as above |
| 21 | `100` | Maximum sensitivity | No | `sensitivity 100 -> lowest threshold` | Same as above |
| 22 | `100` | Default sensitivity | No | `Default sensitivity is 100` | Extract as `DEFAULT_SENSITIVITY` |
| 25 | `0`, `100` | Sensitivity range in mapping | No | `fun rmsThresholdFromSensitivity(sensitivity: Int)` | Already defined conceptually |
| 28 | `0`, `0.01`, `100`, `0.0005` | RMS threshold calculation | No | `0.01 - (sensitivity / 100.0) * 0.0095` | Extract as `MAX_RMS_THRESHOLD`, `RMS_THRESHOLD_SCALE` |
| 29 | `0.01`, `100.0`, `0.0095` | RMS threshold calculation | No | Implementation details | Extract as constants for formula |
| 34 | `0`, `0.1`, `100`, `0.8` | Clarity threshold calculation | No | `0.1 + (sensitivity / 100.0) * 0.7` | Extract as `MIN_CLARITY_THRESHOLD`, `CLARITY_THRESHOLD_SCALE`, `MAX_CLARITY_THRESHOLD` |
| 35 | `0.1`, `100.0`, `0.7` | Clarity threshold calculation | No | Implementation details | Extract as formula constants |
| 40 | `0`, `0.5`, `100`, `0.05` | Probability threshold calculation | No | `0.5f - (sensitivity / 100.0f) * 0.45f` | Extract as `MAX_PROBABILITY_THRESHOLD`, `PROBABILITY_THRESHOLD_SCALE`, `MIN_PROBABILITY_THRESHOLD` |
| 41 | `0`, `100`, `0` | Float conversion values | No | `0.5f`, `100.0f`, `0.45f` | Language syntax (acceptable) |
| 54 | `0.0` | Initial sum for RMS | No | `var sum = 0.0` | Use `INITIAL_SUM` constant |
| 86 | `0.0` | Invalid frequency return | No | `if (estimatedFrequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 91 | `80`, `1350` | Guitar frequency range | No | Comment: "80-1350 Hz" | Extract as `MIN_GUITAR_FREQUENCY`, `MAX_GUITAR_FREQUENCY` |
| 92 | `80.0`, `1350.0` | Guitar frequency validation | No | `estimatedFrequency < 80.0 || estimatedFrequency > 1350.0` | Same as above |
| 93 | `80`, `1350` | Log message values | No | `"Frequency out of guitar range (80-1350 Hz)"` | Already defined conceptually |
| 119 | `2` | Minimum buffer size for YIN | No | `if (audioData.size < 2)` | Extract as `MIN_YIN_BUFFER_SIZE` |
| 119 | `0.0` | Invalid return value | No | `return 0.0` | Use `INVALID_FREQUENCY` constant |
| 125 | `80.0` | Minimum frequency for YIN | No | `val minFreq = 80.0` | Already defined above |
| 126 | `1350.0` | Maximum frequency for YIN | No | `val maxFreq = 1350.0` | Already defined above |
| 127 | `33` | Approximate tau for 1350Hz | No | Comment: "~33 samples for 1350Hz" | Calculate dynamically |
| 128 | `2`, `551` | Tau calculations | No | `Math.min(buffer.size / 2, (sampleRate / minFreq).toInt())` | `2` could be `DIVISOR_FOR_HALF_BUFFER`, `551` is dynamic |
| 130 | `0.0` | Invalid return for condition | No | `if (tauMax <= tauMin) return 0.0` | Use `INVALID_FREQUENCY` |
| 132 | `440.0` | Expected tau calculation | No | `expected tau for 440Hz=${sampleRate/440.0}` | Could use `DEFAULT_REFERENCE_FREQUENCY` |
| 134 | `1` | Loop start index | No | `for (t in 0 until tauMax)` | Standard loop (acceptable) |
| 134 | `0` | Array initialization index | No | `val d = DoubleArray(tauMax)` | Standard initialization |
| 136 | `0` | Loop start for difference function | No | `for (t in 0 until tauMax)` | Standard loop |
| 137 | `0.0` | Initial sum for difference | No | `var sum = 0.0` | Use `INITIAL_SUM` |
| 138 | `0` | Inner loop start | No | `for (j in 0 until buffer.size - t)` | Standard loop |
| 145 | `2` | Divisor in mean calculation | No | `dPrime[t] = d[t] * t / runningSum` | Part of YIN algorithm (algorithmic constant) |
| 147 | `0` | First array index | No | `dPrime[0] = 1.0` | Standard array access |
| 147 | `1.0` | Initial dPrime value | No | `dPrime[0] = 1.0` | YIN algorithm constant |
| 148 | `0.0` | Initial running sum | No | `var runningSum = 0.0` | Use `INITIAL_SUM` |
| 150 | `1` | Loop start (skip index 0) | No | `for (t in 1 until tauMax)` | Standard loop |
| 153 | `0.0` | Zero check for division | No | `if (runningSum == 0.0)` | Use `ZERO` constant |
| 154 | `1.0` | Default dPrime for zero sum | No | `dPrime[t] = 1.0` | YIN algorithm constant |
| 160 | `3` | Loop variable in trough search | No | `for (t in tauMin until tauMax)` | Already uses tauMin |
| 161 | `0.1`, `0.2`, `0.08`, `0.25` | YIN threshold range | No | Comment: "Typical YIN threshold is 0.1-0.2" | Extract as `MIN_YIN_THRESHOLD`, `MAX_YIN_THRESHOLD`, `YIN_THRESHOLD_BASE`, `YIN_THRESHOLD_SCALE` |
| 162 | `0.08`, `0.2125` | Threshold calculation | No | `val threshold = 0.08 + clarityThreshold * 0.2125` | Extract as `YIN_THRESHOLD_OFFSET`, `YIN_THRESHOLD_MULTIPLIER` |
| 163 | `0` | Initial tau value | No | `var tau = 0` | Extract as `INITIAL_TAU` |
| 171 | `4` | Search range for global min | No | `for (t in tauMin until tauMax)` | Already uses tauMin |
| 172 | `0` | Loop variable reinitialization | No | Loop variable `t` | Standard loop |
| 182 | `0` | Check for valid tau | No | `if (tau > 0 && ...)` | Could use `INVALID_TAU` |
| 185 | `0` | Invalid return for unclear pitch | No | `return 0.0` | Use `INVALID_FREQUENCY` |
| 187 | `0.0` | Return value | No | `return 0.0` | Use `INVALID_FREQUENCY` |
| 190 | `5` | Parabolic interpolation check | No | `if (tau > tauMin && tau < tauMax - 1)` | `5` should be `1`? Needs review |
| 191 | `1` | Array bounds check | No | `tau < tauMax - 1` | Array bounds logic |
| 198 | `0.0` | Default frequency for invalid tau | No | `val freq = if (tau >= tauMin) ... else 0.0` | Use `INVALID_FREQUENCY` |
| 205 | `1` | Array offset for interpolation | No | `val s0 = data[tau - 1]` | Standard array access |
| 207 | `1` | Array offset for interpolation | No | `val s2 = data[tau + 1]` | Standard array access |
| 209 | `2.0`, `2.0` | Denominator calculation | No | `val denominator = 2.0 * (2.0 * s1 - s2 - s0)` | Parabolic formula constant |
| 212 | `10` | Small denominator threshold | No | `if (Math.abs(denominator) < 1e-10)` | Extract as `MIN_DENOMINATOR` |
| 227 | `0`, `100` | Sensitivity clamping range | No | `sensitivity.coerceIn(0, 100)` | Already defined as range constants |
| 228 | `0`, `100` | Same as above | No | `val clampedSensitivity = ...` | Already defined |
| 255 | `0.1` | Synthetic duration seconds | No | `val duration = 0.1 // 100ms` | Extract as `SYNTHETIC_DURATION_SECONDS` |
| 258 | `2.0` | PI multiplier for angular freq | No | `val angularFreq = 2.0 * Math.PI * frequency / sampleRate` | Standard formula (acceptable) |
| 259 | `0` | Loop start index | No | `for (i in 0 until samples)` | Standard loop |

**File Summary:** Contains 70 magic numbers, with only 3 already defined as named constants. Many represent pitch detection algorithm parameters that should be extracted for configurability.

### 4. `NoteFinder.kt` - Note frequency calculations

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 21 | `0.0` | Invalid frequency check | No | `if (frequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 22 | `0.0` | Default target frequency | No | `return NoteInfo("--", 0f, 0f, 0.0)` | Use `INVALID_FREQUENCY` |
| 26 | `12.0` | Semitones per octave | No | `12.0 * log2(frequency / referenceFrequency)` | Extract as `SEMITONES_PER_OCTAVE` |
| 32 | `100` | Cents per semitone | No | `((semitonesFromA4 - roundedSemitones) * 100).toFloat()` | Extract as `CENTS_PER_SEMITONE` |
| 34 | `9` | Note index offset for A | No | Comment: "A4 = index 9, since A is 9th note" | Extract as `A_NOTE_INDEX` |
| 35 | `9` | Same offset in calculation | No | `val noteIndex = ((9 + roundedSemitones) % 12 + 12) % 12` | Same as above |
| 36 | `9`, `12`, `12`, `12` | Note index modulo calculation | No | Same line as above | Already uses constants |
| 38 | `4` | A4 octave number | No | Comment: "A4 is octave 4" | Extract as `A4_OCTAVE` |
| 39 | `4`, `9`, `12` | Octave calculation | No | `val octave = 4 + (roundedSemitones + 9) / 12` | Uses above constants |
| 44 | `2.0`, `12.0` | Frequency calculation | No | `referenceFrequency * Math.pow(2.0, roundedSemitones / 12.0)` | Extract as `FREQUENCY_RATIO_BASE`, `SEMITONES_PER_OCTAVE` |
| 46 | `0` | Minimum probability clamp | No | `.coerceIn(0f, 1f)` | Standard clamp (acceptable) |
| 47 | `1`, `50` | Probability calculation | No | `1.0f - (Math.abs(cents) / 50.0f).coerceIn(0f, 1f)` | Extract as `MAX_PROBABILITY`, `MAX_CENTS_FOR_PROBABILITY` |
| 55 | `12` | Notes per octave constant | Yes | `private const val NOTES_PER_OCTAVE = 12` | Already properly defined |
| 58 | `0.0`, `0.0` | Invalid frequency checks | No | `if (frequency <= 0.0 || targetFrequency <= 0.0)` | Use `INVALID_FREQUENCY` |
| 59 | `1200.0` | Cents conversion factor | No | `(1200.0 * log2(frequency / targetFrequency)).toFloat()` | Extract as `CENTS_PER_OCTAVE` |
| 63 | `2.0`, `1200.0` | Frequency ratio from cents | No | `Math.pow(2.0, cents / 1200.0)` | Same constants as above |

**File Summary:** Contains 20 magic numbers, with 1 already defined as a named constant. Many represent musical theory constants that should be extracted.

### 5. `SettingsDialog.kt` - User interface settings

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 30 | `50` | Default sensitivity | No | `sensitivity: Int = 50` | Extract as `DEFAULT_SENSITIVITY` |
| 31 | `1000` | Default display delay (ms) | No | `displayDelayMs: Long = 1000` | Extract as `DEFAULT_DISPLAY_DELAY_MS` |
| 32 | `200` | Default pitch update delay (ms) | No | `pitchUpdateDelayMs: Long = 200` | Extract as `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 74 | `50` | Current sensitivity initial value | No | `private var currentSensitivity = 50` | Use `DEFAULT_SENSITIVITY` |
| 75 | `1000` | Current display delay initial value | No | `private var currentDisplayDelayMs = 1000L` | Use `DEFAULT_DISPLAY_DELAY_MS` |
| 76 | `200` | Current pitch update delay initial value | No | `private var currentPitchUpdateDelayMs = 200L` | Use `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 82 | `50` | Default sensitivity from bundle | No | `it.getInt(ARG_SENSITIVITY, 50)` | Use `DEFAULT_SENSITIVITY` |
| 83 | `1000` | Default display delay from bundle | No | `it.getLong(ARG_DISPLAY_DELAY_MS, 1000)` | Use `DEFAULT_DISPLAY_DELAY_MS` |
| 84 | `200` | Default pitch update delay from bundle | No | `it.getLong(ARG_PITCH_UPDATE_DELAY_MS, 200)` | Use `DEFAULT_PITCH_UPDATE_DELAY_MS` |
| 126 | `430`, `2` | Frequency seekbar calculation | No | `((currentFrequency - 430) * 2).roundToInt()` | Extract as `MIN_REFERENCE_FREQUENCY`, `FREQUENCY_SCALE_FACTOR` |
| 132 | `0`, `1000` | Display delay range comment | No | Comment: "Display delay: 0-1000 ms" | Extract as `MIN_DISPLAY_DELAY_MS`, `MAX_DISPLAY_DELAY_MS` |
| 136 | `0`, `1000` | Pitch update delay range comment | No | Comment: "Pitch update delay: 0-1000 ms" | Extract as `MIN_PITCH_UPDATE_DELAY_MS`, `MAX_PITCH_UPDATE_DELAY_MS` |
| 153 | `430`, `2.0` | Frequency from seekbar progress | No | `currentFrequency = 430 + (progress / 2.0)` | Same constants as above |
| 218 | `430.0`, `450.0` | Frequency validation range | No | `if (newFrequency in 430.0..450.0)` | Extract as `MIN_REFERENCE_FREQUENCY`, `MAX_REFERENCE_FREQUENCY` |
| 220 | `430`, `2` | Seekbar update calculation | No | `((newFrequency - 430) * 2).roundToInt()` | Same constants as above |
| 232 | `430.0`, `450.0` | Frequency clamping range | No | `frequency.coerceIn(430.0, 450.0)` | Same constants as above |
| 236 | `0`, `100` | Sensitivity clamping range | No | `sensitivity.coerceIn(0, 100)` | Extract as `MIN_SENSITIVITY`, `MAX_SENSITIVITY` |

**File Summary:** Contains 20 magic numbers, none defined as named constants. All represent UI configuration parameters that should be extracted.

### 6. `FrequencyUtils.kt` - Frequency utility functions

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 8 | `440.0` | A4 reference frequency | Yes | `private const val A4_FREQUENCY = 440.0` | Already properly defined |
| 9 | `12` | Notes per octave | Yes | `private const val NOTES_PER_OCTAVE = 12` | Already properly defined |
| 16 | `0.0` | Invalid frequency check | No | `if (frequency <= 0.0)` | Extract as `INVALID_FREQUENCY` |
| 16 | `0` | Default semitone return | No | `return Pair("--", 0)` | Extract as `INVALID_SEMITONE` |
| 18 | `12.0` | Semitones per octave | No | `12.0 * log2(frequency / referenceFrequency)` | Use `NOTES_PER_OCTAVE` constant |
| 21 | `12`, `12`, `12` | Note index modulo calculation | No | `((roundedSemitones % 12 + 12) % 12)` | Use `NOTES_PER_OCTAVE` constant |
| 22 | `4`, `9`, `12` | Octave calculation | No | `4 + (roundedSemitones + 9) / 12` | Extract as `A4_OCTAVE`, `A_NOTE_INDEX`, `NOTES_PER_OCTAVE` |
| 29 | `0.0`, `0.0` | Invalid frequency checks | No | `if (frequency <= 0.0 || targetFrequency <= 0.0)` | Use `INVALID_FREQUENCY` |
| 30 | `1200.0` | Cents per octave | No | `(1200.0 * log2(frequency / targetFrequency)).toFloat()` | Extract as `CENTS_PER_OCTAVE` |
| 34 | `2.0`, `12.0` | Frequency calculation | No | `referenceFrequency * 2.0.pow(semitonesFromA4 / 12.0)` | Extract as `FREQUENCY_RATIO_BASE`, use `NOTES_PER_OCTAVE` |
| 38 | `12`, `12`, `12` | Note name index calculation | No | `noteNames[(index % 12 + 12) % 12]` | Use `NOTES_PER_OCTAVE` constant |
| 44 | `6` | Number of octaves to generate | No | Comment: "Generate frequencies for 6 octaves (C2 to B7)" | Extract as `OCTAVES_TO_GENERATE` |
| 45 | `2`, `7` | Octave range for generation | No | `for (octave in 2..7)` | Extract as `MIN_GENERATED_OCTAVE`, `MAX_GENERATED_OCTAVE` |
| 47 | `9`, `4`, `12` | Semitone calculation | No | `noteIndex - 9 + (octave - 4) * 12` | Extract as `A_NOTE_INDEX`, `A4_OCTAVE`, `NOTES_PER_OCTAVE` |
| 70 | `0`, `0.5`, `0.5` | Rounding helper function | No | `if (this >= 0) (this + 0.5).toInt() else (this - 0.5).toInt()` | Extract as `ROUNDING_OFFSET` |

**File Summary:** Contains 23 magic numbers, with 2 already defined as named constants. Many duplicate constants from other files.

### 7. `AudioTestUtils.kt` - Audio testing utilities

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 9 | `1000` | Default sine wave duration (ms) | No | `durationMs: Int = 1000` | Extract as `DEFAULT_SINE_DURATION_MS` |
| 11 | `1000` | Milliseconds per second | No | `(durationMs * sampleRate) / 1000` | Extract as `MILLISECONDS_PER_SECOND` |
| 14 | `2.0` | PI multiplier for angular frequency | No | `2.0 * PI * frequency / sampleRate` | Standard formula (acceptable) |
| 25 | `1` | Duration in seconds comment | No | Comment: "1 second" | Could use constant |
| 29 | `2.0` | PI multiplier for angular frequency | No | `2.0 * PI * fundamental / sampleRate` | Same as above |
| 32 | `1.0`, `0.5`, `0.3`, `0.2`, `0.1` | Harmonic amplitude ratios | No | `listOf(1.0, 0.5, 0.3, 0.2, 0.1)` | Extract as `HARMONIC_AMPLITUDES` array |
| 35 | `0.0` | Initial sample value | No | `var sample = 0.0` | Use `INITIAL_SAMPLE` constant |
| 42 | `2` | Harmonic multiplier offset | No | `fundamental * (harmonicIndex + 2)` | Extract as `HARMONIC_MULTIPLIER_OFFSET` |
| 43 | `2.0` | PI multiplier for harmonic | No | `2.0 * PI * harmonicFreq / sampleRate` | Standard formula |
| 48 | `2.0` | Normalization divisor | No | `(sample / 2.0).toFloat()` | Extract as `NORMALIZATION_FACTOR` |
| 56-61 | `82.41`, `110.0`, `146.83`, `196.0`, `246.94`, `329.63` | Guitar string frequencies | No | Standard guitar tuning frequencies | Extract as named constants |
| 67 | `0.1` | Default noise level | No | `noiseLevel: Float = 0.1f` | Extract as `DEFAULT_NOISE_LEVEL` |
| 69 | `2`, `1` | Noise generation range | No | `(Math.random() * 2 - 1) * noiseLevel` | Extract as `NOISE_RANGE_MULTIPLIER`, `NOISE_RANGE_OFFSET` |
| 81-86 | Same as 56-61 | Guitar tuning frequencies | No | `GUITAR_STANDARD_TUNING` map | Already defined as map values |
| 90-92 | Various | Note frequencies for different octaves | No | Map of note frequencies | Could extract but these are reference data |

**File Summary:** Contains 26 magic numbers, none defined as named constants. Many represent test audio generation parameters.

### 8. `MainActivity.kt` - Main application activity

| Line | Numeric Literal | Description | Named Constant? | Context/Usage | Recommendation |
|------|-----------------|-------------|-----------------|---------------|----------------|
| 38 | `0` | Initial activity start time | No | `private var activityStartTime: Long = 0` | Use `INITIAL_TIME` constant |
| 40 | `0.0` | Initial RMS value | No | `private var currentRms = 0.0` | Use `INITIAL_RMS` constant |
| 42 | `0` | Initial null reads counter | No | `private var consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 43 | `10` | Maximum consecutive null reads | Yes | `private val MAX_CONSECUTIVE_NULL_READS = 10` | Already properly defined |
| 45 | `0` | Initial valid pitch time | No | `private var lastValidPitchTime: Long = 0` | Use `INITIAL_TIME` |
| 52 | `0` | Initial pitch update time | No | `private var lastPitchUpdateTime: Long = 0` | Use `INITIAL_TIME` |
| 56 | `1001` | Audio permission request code | Yes | `private const val AUDIO_PERMISSION_REQUEST_CODE = 1001` | Already properly defined |
| 58 | `100` | Default sensitivity | Yes | `private const val DEFAULT_SENSITIVITY = 100` | Already properly defined |
| 113 | `0` | Reset valid pitch time | No | `lastValidPitchTime = 0` | Use `INITIAL_TIME` |
| 114 | `0` | Reset pitch update time | No | `lastPitchUpdateTime = 0` | Use `INITIAL_TIME` |
| 115 | `0` | Reset null reads counter | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 121 | `0` | Loop iteration counter | No | `var iteration = 0` | Standard variable initialization |
| 124 | `10`, `20`, `100`, `0` | Debug logging thresholds | No | `iteration <= 10 || iteration % 20 == 0 || iteration % 100 == 0` | Extract as `INITIAL_DEBUG_THRESHOLD`, `DEBUG_MODULUS_1`, `DEBUG_MODULUS_2` |
| 137 | `0.0` | Reset RMS value | No | `currentRms = 0.0` | Use `INITIAL_RMS` |
| 141 | `0` | Reset null reads | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 192 | `50` | Loop delay in milliseconds | No | `delay(50) // Update ~20 times per second` | Extract as `TUNING_LOOP_DELAY_MS` |
| 212 | `0` | Reset valid pitch time in stop | No | `lastValidPitchTime = 0` | Use `INITIAL_TIME` |
| 213 | `0` | Reset pitch update time in stop | No | `lastPitchUpdateTime = 0` | Use `INITIAL_TIME` |
| 217 | `0.0` | Reset RMS in stop | No | `currentRms = 0.0` | Use `INITIAL_RMS` |
| 235 | `0` | Reset null reads on restart | No | `consecutiveNullReads = 0` | Use `INITIAL_NULL_READS` |
| 248 | `0.0` | Initial sum for RMS | No | `var sum = 0.0` | Use `INITIAL_SUM` |
| 258 | `0` | Cents comparison for display | No | `if (result.cents > 0)` | Could use `ZERO_CENTS` |
| 267 | `5` | In-tune threshold in cents | No | `absCents < 5` | Extract as `IN_TUNE_THRESHOLD_CENTS` |
| 268 | `0` | Cents comparison for sharp | No | `result.cents > 0` | Could use `ZERO_CENTS` |
| 334 | `0` | Array index for permission result | No | `grantResults[0]` | Standard array access |
| 372 | `2000` | Minimum activity lifetime (ms) | No | `if (elapsed < 2000)` | Extract as `MIN_ACTIVITY_LIFETIME_MS` |

**File Summary:** Contains 26 magic numbers, with 3 already defined as named constants. Many represent timing and threshold values.

---

## Recommendations and Action Plan

### High Priority (Business Logic & Configuration)
1. **Audio constants** in `AudioConfig.kt` are well-defined, but duplicates exist elsewhere
2. **Musical constants** (12 semitones/octave, 1200 cents/octave, A4=440Hz) should be centralized
3. **Threshold values** for pitch detection should be configurable constants
4. **UI timing values** (delays, sensitivities) should be in a configuration class

### Medium Priority (Algorithm Parameters)
1. **YIN algorithm constants** should be extracted with descriptive names
2. **Guitar frequency range** (80-1350Hz) should be constants
3. **Reference frequency tuning range** (430-450Hz) should be constants

### Low Priority (Graphics & Utilities)
1. **Test data constants** (guitar tuning frequencies) could remain as-is
2. **Loop indices and simple arithmetic** (0, 1, 2) are generally acceptable

### Implementation Strategy

1. **Create a `Constants.kt` file** for shared musical/audio constants
2. **Create a `Config.kt` file** for tunable parameters
3. **Update existing files** to use these constants

### Immediate Actions

Based on frequency of use and impact:

1. Extract `SEMITONES_PER_OCTAVE = 12` and `CENTS_PER_OCTAVE = 1200` to shared constants
2. Extract `MIN_GUITAR_FREQUENCY = 80.0` and `MAX_GUITAR_FREQUENCY = 1350.0`
3. Extract `MIN_SENSITIVITY = 0` and `MAX_SENSITIVITY = 100`
4. Extract `DEFAULT_SENSITIVITY = 100` (currently differs between files)
5. Extract all timing constants (`DEFAULT_DISPLAY_DELAY_MS`, etc.)

### Files Requiring Most Attention

1. `PitchDetector.kt` - 70 magic numbers, only 3 named
2. `FrequencyUtils.kt` - 23 magic numbers, duplicates musical constants  
3. `AudioTestUtils.kt` - 26 magic numbers, none named
4. `SettingsDialog.kt` - 20 magic numbers, none named

---

## Conclusion

This Kotlin codebase contains **155 magic numbers** across 8 files, with only **18 already defined as named constants**. While not all numeric literals require extraction (simple indices, loop variables, etc.), the majority represent important configuration values that should be named for clarity and maintainability.

The highest value improvements would be:
1. Centralizing musical theory constants
2. Making audio processing parameters configurable
3. Standardizing UI timing values
4. Documenting pitch detection algorithm parameters

Extracting these magic numbers will make the code more readable, easier to modify, and less prone to errors from inconsistent values across the codebase.

**Generated by opencode analysis on 2026-01-29**